var documenterSearchIndex = {"docs":
[{"location":"#ConstrainedRootSolvers.jl","page":"Home","title":"ConstrainedRootSolvers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A root solver package with constraints.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using ConstrainedRootSolvers\n\n_f_2_solve(x) = exp(-1 * (x/2)^5) - 0.5;\n\nsol = find_zero(_f_2_solve,\n                BisectionMethod{Float64}(x_min=0, x_max=10),\n                SolutionTolerance{Float64}(0.001))\nsol = find_zero(_f_2_solve,\n                NewtonBisectionMethod{Float64}(0.0, 10.0, 2.0),\n                ResidualTolerance{Float64}(0.001))\nsol = find_zero(_f_2_solve,\n                NewtonRaphsonMethod{Float64}(2.0),\n                ResidualTolerance{Float64}(0.001))","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"CurrentModule = ConstrainedRootSolvers","category":"page"},{"location":"API/#Numerical-methods","page":"API","title":"Numerical methods","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"find_zero\nfind_peak","category":"page"},{"location":"API/#ConstrainedRootSolvers.find_zero","page":"API","title":"ConstrainedRootSolvers.find_zero","text":"find_zero(f::F,\n          ms::AbstractCRSMethod{FT},\n          tol::AbstractTolerance{FT};\n          stepping::Bool = false\n) where {F<:Function, FT<:AbstractFloat}\n\nFind the solution, given\n\nf Function to solve\nms AbstractCRSMethod type method struct\ntol AbstractTolerance type tolerance struct\n\nPossible combinations\n\nMethod Type Tolerance Type Pass Test\nBisectionMethod ResidualTolerance Yes\nBisectionMethod SolutionTolerance Yes\nNewtonBisectionMethod ResidualTolerance Yes\nNewtonBisectionMethod SolutionTolerance Yes\nNewtonRaphsonMethod ResidualTolerance Yes\nNewtonRaphsonMethod SolutionTolerance Yes\nReduceStepMethod ResidualTolerance Yes\nReduceStepMethod SolutionTolerance Yes\n\n\n\n\n\n","category":"function"},{"location":"API/#ConstrainedRootSolvers.find_peak","page":"API","title":"ConstrainedRootSolvers.find_peak","text":"find_peak(f::F,\n          ms::AbstractCRSMethod{FT},\n          tol::AbstractTolerance{FT}\n) where {F<:Function, FT<:AbstractFloat}\n\nFind the solution, given\n\nf A function to solve\nms BisectionMethod type method struct\ntol AbstractTolerance type tolerance struct\n\nNote that to compute the lowest value, use -f to make it a peak.\n\nPossible combinations\n\nMethod Type Tolerance type Pass Test\nBisectionMethod SolutionTolerance 2 allocs\nNelderMeadMethod ResidualTolerance N+6 allocs\nNelderMeadMethod SolutionToleranceND N+6 allocs\nReduceStepMethod SolutionTolerance Yes\nReduceStepMethodND SolutionToleranceND 4 allocs\n\n\n\n\n\n","category":"function"},{"location":"API/#Method-options","page":"API","title":"Method options","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"AbstractCRSMethod\nBisectionMethod\nNelderMeadMethod\nNewtonBisectionMethod\nNewtonRaphsonMethod\nReduceStepMethod\nReduceStepMethodND","category":"page"},{"location":"API/#ConstrainedRootSolvers.AbstractCRSMethod","page":"API","title":"ConstrainedRootSolvers.AbstractCRSMethod","text":"abstract type AbstractCRSMethod{FT}\n\nHierachy of AbstractCRSMethod:\n\nBisectionMethod\nNelderMeadMethod\nNewtonBisectionMethod\nNewtonRaphsonMethod\nReduceStepMethod\nReduceStepMethodND\n\n\n\n\n\n","category":"type"},{"location":"API/#ConstrainedRootSolvers.BisectionMethod","page":"API","title":"ConstrainedRootSolvers.BisectionMethod","text":"mutable struct BisectionMethod{FT}\n\nFields\n\nx_min::Any\nlower bound\nx_max::Any\nupper bound\nxy::Matrix{FT} where FT\nmatrix that stores x and y\n\n\n\n\n\n","category":"type"},{"location":"API/#ConstrainedRootSolvers.NelderMeadMethod","page":"API","title":"ConstrainedRootSolvers.NelderMeadMethod","text":"mutable struct NelderMeadMethod{FT}\n\nFields\n\nN::Int64\nNumber of parameters to optimize\nx_inis::Vector{FT} where FT\nInitial values\nsimplex::Array{Vector{FT}, 1} where FT\nSimplex array of array with dimension (N+1) * (N+1)\ncen_x::Vector{FT} where FT\nCentroid\nref_x::Vector{FT} where FT\nReflection\nexp_x::Vector{FT} where FT\nExpansion\ncon_x::Vector{FT} where FT\nContraction\n\n\n\n\n\n","category":"type"},{"location":"API/#ConstrainedRootSolvers.NewtonBisectionMethod","page":"API","title":"ConstrainedRootSolvers.NewtonBisectionMethod","text":"struct NewtonBisectionMethod{FT}\n\nFields\n\nx_min::Any\nLower bound\nx_max::Any\nUpper bound\nx_ini::Any\nInitial guess\n\n\n\n\n\n","category":"type"},{"location":"API/#ConstrainedRootSolvers.NewtonRaphsonMethod","page":"API","title":"ConstrainedRootSolvers.NewtonRaphsonMethod","text":"struct NewtonRaphsonMethod{FT}\n\nFields\n\nx_ini::Any\nInitial guess\n\n\n\n\n\n","category":"type"},{"location":"API/#ConstrainedRootSolvers.ReduceStepMethod","page":"API","title":"ConstrainedRootSolvers.ReduceStepMethod","text":"struct ReduceStepMethod{FT}\n\nFields\n\nx_min::Any\nLower bound\nx_max::Any\nUpper bound\nx_ini::Any\nInitial guess\nΔ_ini::Any\nInitial step\n\n\n\n\n\n","category":"type"},{"location":"API/#ConstrainedRootSolvers.ReduceStepMethodND","page":"API","title":"ConstrainedRootSolvers.ReduceStepMethodND","text":"mutable struct ReduceStepMethodND{FT}\n\nFields\n\nx_mins::Vector{FT} where FT\nLower bound\nx_maxs::Vector{FT} where FT\nUpper bound\nx_inis::Vector{FT} where FT\nInitial guess\nx_targ::Vector{FT} where FT\nTarget x\nx_temp::Vector{FT} where FT\nTemporary x\nΔ_inis::Vector{FT} where FT\nInitial step\nΔ_oper::Vector{FT} where FT\nOperation step\nΔjd::Vector{Bool}\nArray of judges\n\n\n\n\n\n","category":"type"},{"location":"API/#Tolerance-options","page":"API","title":"Tolerance options","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"AbstractTolerance\nResidualTolerance\nSolutionTolerance\nSolutionToleranceND\nif_break\nnext_xy!","category":"page"},{"location":"API/#ConstrainedRootSolvers.AbstractTolerance","page":"API","title":"ConstrainedRootSolvers.AbstractTolerance","text":"abstract type AbstractTolerance{FT}\n\nHierachy of AbstractTolerance:\n\nResidualTolerance\nSolutionTolerance\nStepTolerance\n\n\n\n\n\n","category":"type"},{"location":"API/#ConstrainedRootSolvers.ResidualTolerance","page":"API","title":"ConstrainedRootSolvers.ResidualTolerance","text":"struct ResidualTolerance{FT}\n\nFields\n\ntol::Any\nTolerance for residual\nn_limit::Int64\nlimit of iterations\n\n\n\n\n\n","category":"type"},{"location":"API/#ConstrainedRootSolvers.SolutionTolerance","page":"API","title":"ConstrainedRootSolvers.SolutionTolerance","text":"struct SolutionTolerance{FT}\n\nFields\n\ntol::Any\nTolerance for solution\nn_limit::Int64\nlimit of iterations\n\n\n\n\n\n","category":"type"},{"location":"API/#ConstrainedRootSolvers.SolutionToleranceND","page":"API","title":"ConstrainedRootSolvers.SolutionToleranceND","text":"struct SolutionToleranceND{FT}\n\nFields\n\ntol::Vector{FT} where FT\nTolerance for solution\nn_limit::Int64\nlimit of iterations\n\n\n\n\n\n","category":"type"},{"location":"API/#ConstrainedRootSolvers.if_break","page":"API","title":"ConstrainedRootSolvers.if_break","text":"\n\n\n\n","category":"function"},{"location":"API/#ConstrainedRootSolvers.next_xy!","page":"API","title":"ConstrainedRootSolvers.next_xy!","text":"next_xy!(f::F, xy::Array{FT,2}) where {F<:Function, FT<:AbstractFloat}\n\nDetermine the next points to, given\n\nf Function to find peak\nxy Array of x and y\n\n\n\n\n\n","category":"function"}]
}
